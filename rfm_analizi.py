# -*- coding: utf-8 -*-
"""RFM Analizi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13tfn8b4bj5IWS8zFafO6i8HB82IoRO2K
"""

###############################################################
# RFM ile Müşteri Segmentasyonu Örnek Proje - Erdem Bostancı (Customer Segmentation with RFM)
###############################################################

# 1. İş Problemi (Business Problem)
# 2. Veriyi Anlama (Data Understanding)
# 3. Veri Hazırlama (Data Preparation)
# 4. RFM Metriklerinin Hesaplanması (Calculating RFM Metrics)
# 5. RFM Skorlarının Hesaplanması (Calculating RFM Scores)
# 6. RFM Segmentlerinin Oluşturulması ve Analiz Edilmesi (Creating & Analysing RFM Segments)
# 7. Tüm Sürecin Fonksiyonlaştırılması

###############################################################
# 1. İş Problemi (Business Problem)
###############################################################

# Bir e-ticaret şirketi müşterilerini segmentlere ayırıp bu segmentlere göre
# pazarlama stratejileri belirlemek istiyor.

# Veri Seti Hikayesi
# https://archive.ics.uci.edu/ml/datasets/Online+Retail+II

# Online Retail II isimli veri seti İngiltere merkezli online bir satış mağazasının
# 01/12/2009 - 09/12/2011 tarihleri arasındaki satışlarını içeriyor.

# Değişkenler
#
# InvoiceNo: Fatura numarası. Her işleme yani faturaya ait eşsiz numara. C ile başlıyorsa iptal edilen işlem.
# StockCode: Ürün kodu. Her bir ürün için eşsiz numara.
# Description: Ürün ismi
# Quantity: Ürün adedi. Faturalardaki ürünlerden kaçar tane satıldığını ifade etmektedir.
# InvoiceDate: Fatura tarihi ve zamanı.
# UnitPrice: Ürün fiyatı (Sterlin cinsinden)
# CustomerID: Eşsiz müşteri numarası
# Country: Ülke ismi. Müşterinin yaşadığı ülke.

"""###############################################################
# 2. Veriyi Anlama ve Veri Hazırlama
###############################################################
"""

import datetime as dt
import pandas as pd

pd.set_option('display.max_columns', None)
# pd.set_option('display.max_rows', None)
pd.set_option('display.float_format', lambda x: '%.3f' % x)

df_= pd.read_excel("/content/online_retail_II.xlsx", sheet_name="Year 2009-2010")
df = df_.copy()

df.head() #Verimiz yüklenmiş mi inceleyelim:

df.isnull().sum() #toplam eksik satırlar

df.shape #veri sayısı

df["Description"].nunique() #ürünler faturada kaç kere geçti? (Quantity dahil değil)

df['Description'].value_counts() #Bu da hangi ürünlerin geçtiğiyle beraber (quantity hariç)

df.dropna(inplace=True) #eksik satırları sildik
df.isnull().sum() #eksik satırımız yok

df.describe().T #price-quantity minimum'da eksi ve sıfır değer olması, ft.'lerin iade olduğunu gösteriyor.

df = df[~df['Invoice'].str.contains('C',na=False)] #İade fatura numaraları C ile başlıyor. Bunları kaldırdık.

df.shape

df['Ürün_Toplam_Fiyatı'] = df['Quantity'] * df['Price'] #Bir Ft. içinde alınan toplam ürün fiyatı değişkeni oluşturduk.

df.groupby('Invoice').agg({'Ürün_Toplam_Fiyatı':sum}) #İncelemek adına her ft. üzerinde yapılan toplam harcamayı görelim.
# Hem de 'Monetary' değerini önceden hesaplamış oluruz.

"""---

## RFM Metriklerinin Hesaplanması

---




"""

#Recency, Frequency, Monetary Hesaplanması:
today_Date=dt.datetime(2010,12,11)

df.groupby('Invoice').agg({'InvoiceDate':'max'}).head()

rfm_ = df.groupby('Customer ID').agg({'InvoiceDate':(lambda InvoiceDate: (today_Date - InvoiceDate.max()).days),
                                      'Invoice': lambda Invoice: Invoice.nunique(),
                                      'Ürün_Toplam_Fiyatı':lambda Ürün_Toplam_Fiyatı:Ürün_Toplam_Fiyatı.sum()})
#RFM metriklerini hesaplamak için lambda fonksiyonuyla hızlı bir formül verdik ve yeni sütun olarak yerleştirdik.

rfm_.head()

rfm_.columns = ['Recency','Frequency','Monetary'] #Hesaplama yaptığımız sütunların ismini değiştirdik.

rfm_ = rfm_[rfm_['Monetary']>0] #Monetary değerinde iade ft.lerden kalan '0' değerler vardı minimumda... Bunları kaldırdık.

rfm_.describe().T

"""

---

RFM SKORLARININ HESAPLANMASI


---"""

rfm_['Recency_Score']=pd.qcut(rfm_['Recency'],5,labels=[5,4,3,2,1])
rfm_['Frequency_Score']=pd.qcut(rfm_['Frequency'].rank(method='first'),5,labels=[1,2,3,4,5])
rfm_['Monetary_Score']=pd.qcut(rfm_['Monetary'],5,labels=[1,2,3,4,5])
#pd.qcut fonksiyonu ile eşit aralıklara bölerek 1-5 arasında puanlamaya tabi tuttuk.
#Frequency skorunda ft. ID'ye göre sıralama yaptığından belirli eşit parçalara bölemedi bu yüzden .rank() objesini kullandık.

rfm_.head()

rfm_['rfm_score'] = (
    rfm_['Recency_Score'].astype(str) +
    rfm_['Frequency_Score'].astype(str) +
    rfm_['Monetary_Score'].astype(str))
#Her bir müşteri ID üzerinden tam bir puanlama yapmak için hepsini string bilgi yapıp topladık.

rfm_.head() #En sağda tam RFM skorumuz görünüyor.

# Recency ve Frequency

from matplotlib import pyplot as plt
rfm_.plot(kind='scatter', x='Recency', y='Frequency', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

"""

---


RFM SKORLARINA GÖRE MÜŞTERİLERİ ID'LERİNİN SEGMENTE EDİLMESİ


---

"""

seg_map = {
    r'[1-2][1-2][1-5]': 'uykuda',
    r'[1-2][3-4][1-5]': 'riskli',
    r'[1-2]5[1-5]': 'kaybedilmemeli',
    r'3[1-2][1-5]': 'uyumak_uzere',
    r'33[1-5]': 'dikkat',
    r'[3-4][4-5][1-5]': 'sadik',
    r'41[1-5]': 'umit_verici',
    r'51[1-5]': 'yeni',
    r'[4-5][2-3][1-5]': 'potansiyel_sadik',
    r'5[4-5][1-5]': 'sampiyon'
}
#Segmente edilirken Monetary Score genelde konulmaz. Ancak yine de incelenmesi açısından sütuna ekledim.

rfm_['segment'] = rfm_['rfm_score'].replace(seg_map, regex=True)
rfm_.head()

rfm_[['segment','Recency','Frequency','Monetary']].groupby('segment').agg(['mean','count'])

"""

---


## FONKSIYONLASTIRMA


---


"""

def create_rfm(dataframe, csv=False):

    # Veri hazırlama
    dataframe["TotalPrice"] = dataframe["Quantity"] * dataframe["Price"]
    dataframe.dropna(inplace=True)
    dataframe = dataframe[~dataframe["Invoice"].str.contains("C", na=False)]

    # RFM metrik hesaplama
    today_date = dt.datetime(2011, 12, 11)
    rfm = dataframe.groupby('Customer ID').agg({'InvoiceDate': lambda date: (today_date - date.max()).days,
                                                'Invoice': lambda num: num.nunique(),
                                                "TotalPrice": lambda price: price.sum()})
    rfm.columns = ['recency', 'frequency', "monetary"]
    rfm = rfm[(rfm['monetary'] > 0)]

    # RFM skor hesaplaması
    rfm["recency_score"] = pd.qcut(rfm['recency'], 5, labels=[5, 4, 3, 2, 1])
    rfm["frequency_score"] = pd.qcut(rfm["frequency"].rank(method="first"), 5, labels=[1, 2, 3, 4, 5])
    rfm["monetary_score"] = pd.qcut(rfm['monetary'], 5, labels=[1, 2, 3, 4, 5])


    #
    rfm["RFM_SCORE"] = (rfm['recency_score'].astype(str) +
                        rfm['frequency_score'].astype(str))


    # segmentleri  isimlendirme
    seg_map = {
        r'[1-2][1-2]': 'hibernating',
        r'[1-2][3-4]': 'at_risk',
        r'[1-2]5': 'cant_loose',
        r'3[1-2]': 'about_to_sleep',
        r'33': 'need_attention',
        r'[3-4][4-5]': 'loyal_customers',
        r'41': 'promising',
        r'51': 'new_customers',
        r'[4-5][2-3]': 'potential_loyalists',
        r'5[4-5]': 'champions'
    }

    rfm['segment'] = rfm['RFM_SCORE'].replace(seg_map, regex=True)
    rfm = rfm[["recency", "frequency", "monetary", "segment"]]
    rfm.index = rfm.index.astype(int)

    if csv:
        rfm.to_csv("rfm.csv")

    return rfm


df = df_.copy()

rfm_new = create_rfm(df, csv=True)